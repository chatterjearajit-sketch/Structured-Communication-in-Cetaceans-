import numpy as np
import soundfile as sf
from collections import Counter, defaultdict

# STEP 1: Quantize audio
def quantize_wav(wavfile, n_symbols=8):
    data, sr = sf.read(wavfile)
    if data.ndim > 1:
        data = data.mean(axis=1)  # mono
    data = (data - data.min()) / (data.max() - data.min())
    quantized = np.floor(data * n_symbols).astype(int)
    quantized[quantized == n_symbols] = n_symbols - 1
    return quantized

# STEP 2: Estimate run-length distribution and transition matrix
def rp_params(sequence, n_symbols):
    runs = defaultdict(list)
    trans_counts = np.zeros((n_symbols, n_symbols), dtype=int)
    prev = sequence[0]
    count = 1
    for s in sequence[1:]:
        if s == prev:
            count += 1
        else:
            runs[prev].append(count)
            trans_counts[prev, s] += 1
            prev = s
            count = 1
    runs[prev].append(count)
    # Estimate mean repeat for each symbol
    mu = np.array([np.mean(runs[i]) if runs[i] else 1.0 for i in range(n_symbols)])
    # Off-diagonal normalization for transition probabilities
    for i in range(n_symbols):
        trans_counts[i,i] = 0
    trans_probs = np.divide(trans_counts, trans_counts.sum(axis=1, where=trans_counts.sum(axis=1)!=0)[:,None],
                            out=np.zeros_like(trans_counts, dtype=float), where=trans_counts.sum(axis=1)[:,None]!=0)
    return mu, trans_probs

# STEP 3: Generate a sequence from the RP model
def generate_rp_sequence(mu, trans_probs, length, seed=42):
    np.random.seed(seed)
    n_symbols = len(mu)
    # Start from a random symbol
    current = np.random.choice(n_symbols)
    generated = []
    while len(generated) < length:
        repeats = np.random.poisson(mu[current])
        repeats = max(1, repeats)
        generated.extend([current] * repeats)
        if len(generated) >= length: break
        # Select next symbol (not current)
        probs = trans_probs[current]
        if probs.sum() == 0:
            next_symbol = np.random.choice([i for i in range(n_symbols) if i != current])
        else:
            next_symbol = np.random.choice(n_symbols, p=probs)
        current = next_symbol
    return np.array(generated[:length])

# STEP 4: Compute entropy (optionally, order-0 or order-1)
def shannon_entropy(seq):
    cnt = Counter(seq)
    probs = np.array(list(cnt.values())) / len(seq)
    return -np.sum(probs * np.log2(probs))

# USAGE EXAMPLE
wav_file = "/content/audiomass-output (1).wav"
n_symbols = 8
quantized = quantize_wav(wav_file, n_symbols=n_symbols)
mu, trans_probs = rp_params(quantized, n_symbols)
simulated = generate_rp_sequence(mu, trans_probs, length=10000)
S_entropy = shannon_entropy(simulated)
print(f"Shannon entropy of simulated RP sequence: {S_entropy:.4f} bits/symbol")

# Compare to original entropy
print(f"Original sequence entropy: {shannon_entropy(quantized):.4f} bits/symbol")
